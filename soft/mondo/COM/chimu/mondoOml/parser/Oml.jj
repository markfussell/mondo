/* Generated By:JJTree: Do not edit this line. Oml.jj */
options {
ERROR_REPORTING=true;
STATIC=false;
USER_CHAR_STREAM=false;
OTHER_AMBIGUITY_CHECK=1;
BUILD_TOKEN_MANAGER=true;
DEBUG_TOKEN_MANAGER=false;
DEBUG_LOOKAHEAD=false;
USER_TOKEN_MANAGER=false;
LOOKAHEAD=1;
IGNORE_CASE=false;
FORCE_LA_CHECK=false;
SANITY_CHECK=true;
JAVA_UNICODE_ESCAPE=true;
CHOICE_AMBIGUITY_CHECK=2;
BUILD_PARSER=true;
DEBUG_PARSER=false;
COMMON_TOKEN_ACTION=false;
UNICODE_INPUT=false;
}

PARSER_BEGIN(OmlParser)
package COM.chimu.mondoOml.parser;
import java.util.Stack;

public class OmlParser{

    public static void main(String args[]) {
        OmlParser parser;
        if (args.length == 0) {
            System.out.println("Oml Parser Version 0.1:  Reading from standard input . . .");
            parser = new OmlParser(new java.io.DataInputStream(System.in));
        } else if (args.length == 1) {
            System.out.println("Oml Parser Version 0.1:  Reading from file " + args[0] + " . . .");
            try {
                parser = new OmlParser(new java.io.DataInputStream(new java.io.FileInputStream(args[0])));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("Oml Parser Version 0.1:  File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("Oml Parser Version 0.2:  Usage is one of:");
            System.out.println("         java COM.chimu.ocmlparser.OmlParser < inputfile");
            System.out.println("OR");
            System.out.println("         java COM.chimu.ocmlparser.OmlParser inputfile");
            return;
        }
        try {
            parser.setupForText();
            parser.TextItems();
            System.out.println("Oml Parser Version 0.1:  Oml Document parsed successfully.");

            SimpleNode rootNode = (SimpleNode) parser.jjtree.rootNode();
            rootNode.dump("");
            Visitor visitor = new DumpVisitorClass();
            visitor.visitSimpleNode(rootNode);

        } catch (ParseError e) {
            System.out.println("Oml Parser Version 0.1:  Encountered errors during parse.");
            System.out.println("Parsed the following tree:");
            SimpleNode rootNode = (SimpleNode) parser.jjtree.rootNode();
            rootNode.dump("");
        }
    }

    //******************************************
    //******************************************
    //******************************************

        /**
         * pushLexState and popLexState handle
         * the return from a lexical mode to its
         * enclosing state when the enclosing state
         * may vary.  This occurs for Element
         * because Elements can be within other Elements
         * (as a ParameterValue) or with Content.
         */
    void pushLexState() {
        stateStack[stackPos++] = lexState;
        // stateStack.push(new Integer(lexState));
        lexState = token_source.curLexState;
    }

    void popLexState() {
        lexState = stateStack[--stackPos];
        // lexState = ((Integer) stateStack.pop()).intValue();
        token_source.SwitchTo(lexState);
    }

    public JJTOmlParserState jjtree() {
        return jjtree;
    }

    public SimpleNode rootParseNode() {
        try {
            return (SimpleNode) this.jjtree.rootNode();
        } catch (Exception e) {};
        return null;
    }

    private int   lexState   = TextSect;
    private int[] stateStack = new int[100];
    private int   stackPos   = 0;

 //   private Stack stateStack = new Stack();

    //******************************************
    //******************************************
    //******************************************

    public void setupForContent() {
        lexState = TextSect;
        token_source.SwitchTo(lexState);
    }

    public void setupForText() {
        lexState = TextSect;
        token_source.SwitchTo(lexState);
    }

    public void setupForList() {
        lexState = ListSect;
        token_source.SwitchTo(lexState);
    }

    public void setupForElement() {
        lexState = ElementSect;
        token_source.SwitchTo(lexState);
    }


    //******************************************
    //******************************************
    //******************************************

    void elementCloseMismatchError(String openName, String closeName, Token beginTok, Token endTok) {
        int beginLine   = beginTok.beginLine;
        int beginColumn = beginTok.beginColumn;
        int endLine     = endTok.endLine;
        int endColumn   = endTok.endColumn;

        System.err.println(
                "Element opened with "+openName+" but closed with "+closeName+
                " ("+beginLine+":"+beginColumn+"->"+endLine+":"+endColumn+
                ") "
            );
    }
  protected JJTOmlParserState jjtree = new JJTOmlParserState();
    //******************************************
    //******************************************
    //******************************************

}
final class JJTOmlParserState {
  /* JJTree builds the AST bottom up.  It constructs nodes and places
     them on a stack.  When all the children have been assembled, they
     are added to their parent and popped from the stack. */
  private JJTOmlParserNodeStack nodes;

  /* The current node is kept on the top of this stack so that user
     actions can always refer to it. */
  private java.util.Stack current_nodes;

  /* We keep track of whether a node was actually created.  Definite
     and indefinite nodes always are, but GT nodes are only closed and
     pushed on the stack if their conditions are true. */
  private boolean node_created;

  JJTOmlParserState() {
    nodes = new JJTOmlParserNodeStack();
    current_nodes = new java.util.Stack();
  }

  /* Determine whether the current node was actually closed and pushed */
  boolean nodeCreated() {
    return node_created;
  }

  /* Called when the current node has been completely finished with.
     Makes a new node the current node. */
  void updateCurrentNode(int n) {
    for (int i = 0; i < n; ++i) {
      current_nodes.pop();
    }
  }

  /* Call this to reinitialize the node stack.  */
  void reset() {
    nodes.empty();
    current_nodes = new java.util.Stack();
  }

  /* Return the root node of the AST. */
  Node rootNode() {
    return nodes.elementAt(0);
  }

  /* Return the most recently constructed node. */
  Node currentNode() {
    return (Node)current_nodes.peek();
  }

  /* Push a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
  }

  /* Return the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    return nodes.pop();
  }

  /* Return the node currently on the top of the stack. */
  Node peekNode() {
    return nodes.peek();
  }

  /* An indefinite node has an unspecified number of children.  When
     it is closed it collects up all nodes that have been pushed since
     it was begun and becomes their parent, and then it is pushed on
     to the stack. */

  void openIndefiniteNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeIndefiniteNode() {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTOmlParserNodeEnum e = nodes.elementsSinceLastMark();
	 e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popToLastMark();
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A definite node is constructed from a fixed number of children.
     That number of nodes are popped from the stack and made the
     children of the definite node.  Then the definite node is pushed
     on to the stack. */

  void openDefiniteNode(Node n) {
    current_nodes.push(n);
  }

  void closeDefiniteNode(int num) {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTOmlParserNodeEnum e = nodes.elementsTop(num); e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popTop(num);
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A GT (Greater Than) node is constructed if more than the
     specified number of nodes have been pushed since it was begun.
     All those nodes are made children of the the GT node, which is
     then pushed on to the stack.  If fewer have been pushed the node
     is not constructed and they are left on the stack. */

  void openGTNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeGTNode(int num) {
    if (nodes.numElementsSinceLastMark() > num) {
      closeIndefiniteNode();
    } else {
      nodes.removeLastMark();
      node_created = false;
    }
  }
}

final class JJTOmlParserNodeStack {
  private Node[] nodeStack;
  private int[] markStack;
  private int nodeSP;
  private int markSP;

  JJTOmlParserNodeStack() {
    nodeStack = new Node[500];
    markStack = new int[500];
    nodeSP = 0;
    markSP = 0;
  }

  void empty() {
    if (nodeSP > 0) {
      while (--nodeSP >= 0) {
	nodeStack[nodeSP] = null;
      }
    }
    nodeSP = 0;
    markSP = 0;
  }

  Node elementAt(int i) {
    return nodeStack[i];
  }

  Node elementFromTop(int i) {
    return nodeStack[nodeSP - i - 1];
  }

  void push(Node n) {
    if (nodeSP == nodeStack.length) {
      Node[] ns = new Node[nodeStack.length * 2];
      System.arraycopy(nodeStack, 0, ns, 0, nodeStack.length);
      nodeStack = ns;
    }
    nodeStack[nodeSP++] = n;
  }

  Node pop() {
    Node n = nodeStack[--nodeSP];
    nodeStack[nodeSP] = null;
    return n;
  }

  Node peek() {
    return nodeStack[nodeSP - 1];
  }

  void mark() {
    if (markSP == markStack.length) {
      int[] ms = new int[markStack.length * 2];
      System.arraycopy(markStack, 0, ms, 0, markStack.length);
      markStack = ms;
    }
    markStack[markSP++] = nodeSP;
  }

  void removeLastMark() {
    --markSP;
  }

  int numElementsSinceLastMark() {
    return nodeSP - markStack[markSP - 1];
  }

  JJTOmlParserNodeEnum elementsSinceLastMark() {
    return new JJTOmlParserNodeEnum(nodeStack, nodeSP, markStack[markSP - 1]);
  }

  void popToLastMark() {
    --markSP;
    while (nodeSP > markStack[markSP]) {
      nodeStack[--nodeSP] = null;
    }
  }

  JJTOmlParserNodeEnum elementsTop(int n) {
    return new JJTOmlParserNodeEnum(nodeStack, nodeSP, nodeSP - n);
  }

  void popTop(int n) {
    for (int i = 0; i < n; ++i) {
      nodeStack[--nodeSP] = null;
    }
  }
}

final class JJTOmlParserNodeEnum implements java.util.Enumeration {
  private Node[] nodes;
  private int topSP, index;

  JJTOmlParserNodeEnum(Node[] s, int top, int start) {
    nodes = s;
    topSP = top;
    index = start;
  }

  public boolean hasMoreElements() {
    return index < topSP;
  }

  public Object nextElement() {
    return nodes[index++];
  }
}

PARSER_END(OmlParser)

/*****************************************
 * OML TOKENS START HERE *
 *****************************************/

//******************************************
//******************************************
//******************************************
// There are four lexical modes:
//     ElementSect, ValueSect, ListSect, TextSect
//

<ElementSect,ValueSect,ListSect,TextSect> TOKEN : {
<TAGO: "<"> : ElementSect
}


<ElementSect,ValueSect,ListSect> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
}


<ElementSect,ValueSect,ListSect> TOKEN : {
<TXTO: "{"> : TextSect
| <LSTO: "("> : ListSect
}


<ElementSect,ValueSect,ListSect> SPECIAL_TOKEN : {
<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
| <SGML_COMMENT: "--" (~["-"])* "-" ((~["-"])* "-" )* "-" >
| <SGML_COMMENT2: "!--" (~["-"])* "-" ((~["-"])* "-" )* "-" >
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*" )* "/" >
}


<ElementSect,ValueSect,ListSect> TOKEN : {
<StringSQ: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\'" >
| <StringDQ: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\"" >
| <StringLQ: "[[" (~["]"] | "]" ~["]"] )* "]]" >
| <StringVLQ: "[CDATA[" (~["]"] | "]" ~["C"]  | "]C" ~["D"]  | "]CD" ~["A"]  | "]CDA" ~["T"]  | "]CDAT" ~["A"] )* "]" "CDATA" "]" >
}

//******************************************
//******************************************
//******************************************

<TextSect> TOKEN : {
<TXTC: "}">
| <Chars: (~["<","}","\\"] | "\\" ["n","t","b","r","f","\\","\'","\"","}","<"]  | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] )+>
}

//******************************************
//******************************************
//******************************************

<ListSect> TOKEN : {
<LSTC: ")">
}

//******************************************
//******************************************
//******************************************

<ElementSect> TOKEN : {
<TAGC: ">">
| <EQ: "="> : ValueSect
| <#Letter: ["a"-"z","A"-"Z"]>
| <#Digit: ["0"-"9"]>
| <#MiscName: "." | "-" | "_" | ":">
| <#NameChar: <Letter> | <Digit> | <MiscName>>
| <#LetterName: <Letter> (<NameChar>)* >
| <#Prefix: ["?","!","&"]>
| <#PrefixName: <Prefix> (<LetterName>)? >
| <Name: <LetterName> | <PrefixName>>
}

/*
!-- => beginning of comment
--  =>
! OK

|  < #Letter:  ["a"-"z","A"-"Z"] >
|  < #Digit:   ["0"-"9"] >
|  < #MiscName:  "." | "-" | "_" | ":" >
|  < #NameChar:   <Letter> |  <Digit> | <MiscName> >
|  < #LetterName: <Letter> ( <NameChar> )* >

( <Letter> ( <NameChar> )* )?
|  < Chars:
     (  (~["!"])

      | ( "\\"
            ( ["n","t","b","r","f","\\","'","\"","}","<"] )
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        )
        )+
   >

!:Foo-Bar
!123
<Foo
!

<Prefix> <AfterPrefix> <NameChar>
<Letter> <NameChar>

<123>
*/


//******************************************
//******************************************
//******************************************

<ElementSect,ValueSect,ListSect> TOKEN : {
<DirectLiteral: ~["\"","\n","\r"," ","\t","\'","{","}","<",">","(",")","=","/"] (~["\\","\"","\n","\r"," ","\t","\'","{","}","<",">","(",")","=","/"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* >
}

/*****************************************
 * OML GRAMMAR STARTS HERE *
 *****************************************/



//******************************************
//******************************************
//******************************************
SimpleNode Element() /*#Element*/ :
{
Token tok;
    Token beginTok, endTok;
    String openName, closeName;
    SimpleNode  node  = null;
}
{
{
jjtree.openIndefiniteNode(AST_Element.jjtCreate("Element"));
}
 beginTok=<TAGO> { try {
AST_Element jjtThis = (AST_Element)jjtree.currentNode();
pushLexState();
} finally {
}
}
 tok=<Name> { try {
AST_Element jjtThis = (AST_Element)jjtree.currentNode();
jjtThis.setName(tok.image); openName = tok.image.toUpperCase();
} finally {
}
}
 (  node=Parameter() |  UnnamedParameter() { try {
AST_Element jjtThis = (AST_Element)jjtree.currentNode();
node = null;
} finally {
}
}
  )* endTok=<TAGC> { try {
AST_Element jjtThis = (AST_Element)jjtree.currentNode();
popLexState();

        if (node != null) {  //We have a potention closing label
            AST_Parameter parameter = (AST_Parameter) node;
            if ( parameter.hasNoValue() ) {
                closeName = parameter.name.toUpperCase();
                if (! closeName.equals(openName) ) {
                    elementCloseMismatchError(openName, closeName, beginTok, endTok);
                }
            }
        }
} finally {
}
}
 {
jjtree.closeIndefiniteNode();
}
{ try {
AST_Element jjtThis = (AST_Element)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

SimpleNode Parameter() /*#Parameter*/ :
{
Token tok;
    Token value = null;
    Node  node = null;
}
{
{
jjtree.openIndefiniteNode(AST_Parameter.jjtCreate("Parameter"));
}
 tok=<Name> { try {
AST_Parameter jjtThis = (AST_Parameter)jjtree.currentNode();
jjtThis.setName(tok.image);
} finally {
}
}
 (  <EQ> Value() )? {
jjtree.closeIndefiniteNode();
}
{ try {
AST_Parameter jjtThis = (AST_Parameter)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

SimpleNode UnnamedParameter() /*#UnnamedParameter*/ : {}
{
{
jjtree.openIndefiniteNode(AST_UnnamedParameter.jjtCreate("UnnamedParameter"));
}
 DelimitedValue() {
jjtree.closeIndefiniteNode();
}
{ try {
AST_UnnamedParameter jjtThis = (AST_UnnamedParameter)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

//******************************************
//******************************************
//******************************************

SimpleNode Value() /*#void*/ :
{
Node  node = null;
}
{
 (  node=DirectValue() |  node=DelimitedValue()  ) { try {
return (SimpleNode) node;
} finally {
}
}

}

SimpleNode DirectValue() /*#DirectValue*/ :
{
Token value = null;
}
{
{
jjtree.openIndefiniteNode(AST_DirectValue.jjtCreate("DirectValue"));
}
 { try {
AST_DirectValue jjtThis = (AST_DirectValue)jjtree.currentNode();
pushLexState();
} finally {
}
}
 value=<DirectLiteral> { try {
AST_DirectValue jjtThis = (AST_DirectValue)jjtree.currentNode();
popLexState();
} finally {
}
}
 {
jjtree.closeIndefiniteNode();
}
{ try {
AST_DirectValue jjtThis = (AST_DirectValue)jjtree.currentNode();
jjtThis.setValue(value.image);  return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

SimpleNode DelimitedValue() /*#void*/ :
{
Node  node = null;
}
{
 { try {
pushLexState();
} finally {
}
}
 (  node=StringLiteral() |  node=Element() |  node=List() |  node=Text()  ) { try {
popLexState();
} finally {
}
}
 { try {
return (SimpleNode) node;
} finally {
}
}

}

//******************************************
//******************************************
//******************************************

SimpleNode StringLiteral() /*#String*/ :
{
Token value = null;
}
{
{
jjtree.openIndefiniteNode(AST_String.jjtCreate("String"));
}
 (  value=<StringSQ> {
jjtree.closeIndefiniteNode();
}
{ try {
AST_String jjtThis = (AST_String)jjtree.currentNode();
jjtThis.setValue_unquote(value.image,1); return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}
 |  value=<StringDQ> {
jjtree.closeIndefiniteNode();
}
{ try {
AST_String jjtThis = (AST_String)jjtree.currentNode();
jjtThis.setValue_unquote(value.image,1); return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}
 |  value=<StringLQ> {
jjtree.closeIndefiniteNode();
}
{ try {
AST_String jjtThis = (AST_String)jjtree.currentNode();
jjtThis.setValue_unquoteDChar(value.image,'['); return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}
 |  value=<StringVLQ> {
jjtree.closeIndefiniteNode();
}
{ try {
AST_String jjtThis = (AST_String)jjtree.currentNode();
jjtThis.setValue_unquoteDChar(value.image,'['); return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}
  )
}

//******************************************
//******************************************
//******************************************

SimpleNode List() /*#void*/ :
{
SimpleNode  node  = null;
}
{
 <LSTO> { try {
pushLexState();
} finally {
}
}
 node=ListItems() <LSTC> { try {
popLexState();  return (SimpleNode) node;
} finally {
}
}

}

SimpleNode ListItems() /*#List*/ :
{
SimpleNode  node  = null;
}
{
{
jjtree.openIndefiniteNode(AST_List.jjtCreate("List"));
}
 (  node=Value() { try {
AST_List jjtThis = (AST_List)jjtree.currentNode();
jjtThis.appendNode(node);
} finally {
}
}
 )* {
jjtree.closeIndefiniteNode();
}
{ try {
AST_List jjtThis = (AST_List)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

//******************************************
//******************************************
//******************************************

SimpleNode Text() /*#void*/ :
{
Token       value = null;
    SimpleNode  node  = null;
}
{
 <TXTO> { try {
pushLexState();
} finally {
}
}
 node=TextItems() <TXTC> { try {
popLexState();  return (SimpleNode) node;
} finally {
}
}

}

SimpleNode TextItems() /*#Text*/ :
{
Token       value = null;
    SimpleNode  node  = null;
}
{
{
jjtree.openIndefiniteNode(AST_Text.jjtCreate("Text"));
}
 (  (  value=<Chars> |  node=Element()  ) { try {
AST_Text jjtThis = (AST_Text)jjtree.currentNode();
if (value != null) {
                jjtThis.appendChars(value.image);
                value = null;
            };
            if (node != null) {
                jjtThis.appendNode(node);
                node = null;
            };
} finally {
}
}
 )* {
jjtree.closeIndefiniteNode();
}
{ try {
AST_Text jjtThis = (AST_Text)jjtree.currentNode();
return jjtThis;
} finally {
jjtree.updateCurrentNode(1);
}
}

}

//******************************************
//******************************************
//******************************************

void ObjectListFile() /*#void*/ : {}
{
 { try {
setupForList();
} finally {
}
}
 ListItems() <EOF>
}

/*
 * Program structuring syntax follows.
 */
//Disable the <EOF>??
void TextFile() /*#void*/ : {}
{
 { try {
setupForText();
} finally {
}
}
 TextItems() <EOF>
}

